"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _events = _interopRequireDefault(require("events"));

var _mqtt = _interopRequireDefault(require("mqtt"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _tinycache = _interopRequireDefault(require("tinycache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var uuidv4 = require('uuid/v4');

var BaseClient =
/*#__PURE__*/
function (_events$EventEmitter) {
  _inherits(BaseClient, _events$EventEmitter);

  function BaseClient(config) {
    var _this;

    _classCallCheck(this, BaseClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseClient).call(this));
    _this.log = _loglevel["default"];

    _this.log.setDefaultLevel(config.options.logLevel);

    _this.config = config;
    _this.reconnectLog = 0;
    _this.mqtt = null;
    _this.lostConnectionLog = new _tinycache["default"]();
    return _this;
  }

  _createClass(BaseClient, [{
    key: "isConnected",
    value: function isConnected() {
      if (this.mqtt == null) {
        return false;
      }

      return this.mqtt.connected;
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      if (this.mqtt != null) {
        this.log.info("[BaseClient:connect] Reconnecting to " + this.config.getMqttHost() + " as " + this.config.getClientId());
        this.mqtt.reconnect();
        return;
      }

      this.log.info("[BaseClient:connect] Connecting to " + this.config.getMqttHost() + " as " + this.config.getClientId());
      this.mqtt = _mqtt["default"].connect(this.config.getMqttHost(), this.config.getMqttConfig());
      /* Events coming from mqtt
       * Event 'connect' - Emitted on successful (re)connection (i.e. connack rc=0).
       * Event 'reconnect' - Emitted when a reconnect starts.
       * Event 'close' - Emitted after a disconnection.
       * Event 'offline' - Emitted when the client goes offline.
       * Event 'error' - Emitted when the client cannot connect (i.e. connack rc != 0) or when a parsing error occurs.
       * Event 'end' - Emitted when mqtt.Client#end() is called. If a callback was passed to mqtt.Client#end(), this event is emitted once the callback returns.
       * Event 'message' - Emitted when the client receives a publish packet
       * Event 'packetsend' - Emitted when the client sends any packet. This includes .published() packets as well as packets used by MQTT for managing subscriptions and connections
       * Event 'packetreceive' - Emitted when the client receives any packet. This includes packets from subscribed topics as well as packets used by MQTT for managing subscriptions and connections
       */

      this.mqtt.on('connect', function () {
        _this2.log.info("[BaseClient:onConnect] MQTT client is connected.");

        _this2.emit('connect'); // less than 3 connect attempts you get put to a connect delay of 1 second
        // after 3 connect attempts you get put to a connect delay of 2 seconds (3 seconds elapsed - 3 attempts @ 1 second intervals)
        // after 6 connect attempts you get put to a connect delay of 5 seconds (3 + 6 seconds elapsed - 3 attempts @ 2 second intervals)
        // after 9 connect attempts you get put to a connect delay of 20 seconds (3 + 6 + 15 seconds elapsed - 3 attempts @ 5 second intervals)


        var connectionLostCount = _this2.lostConnectionLog.size; // Default is 1 second reconnect period

        var reconnectPeriod = 1000;

        if (connectionLostCount >= 9) {
          reconnectPeriod = 20000; // Log this and raise the error EVERY time we reconnect under these conditions.

          _this2.log.warn("[BaseClient:onOffline] This client is likely suffering from clientId stealing (where two connections try to use the same client Id).");

          _this2.emit("error", "Exceeded 9 connection losses in a 5 minute period.  Check for clientId conflict with another connection.");
        } else if (connectionLostCount >= 6) {
          reconnectPeriod = 5000;
        } else if (connectionLostCount >= 3) {
          reconnectPeriod = 2000;
        }

        if (reconnectPeriod != _this2.mqtt.options.reconnectPeriod) {
          _this2.log.info("[BaseClient:onOffline] Client has lost connection " + connectionLostCount + " times during the last 5 minutes, reconnect delay adjusted to " + reconnectPeriod + " ms");

          _this2.mqtt.options.reconnectPeriod = reconnectPeriod;
        }
      });
      this.mqtt.on('reconnect', function () {
        _this2.log.info("[BaseClient:onReconnect] MQTT client is reconnecting."); // this.log.debug("[BaseClient:onReconnect] Resubscribe topics:");
        // this.log.debug(this.mqtt._resubscribeTopics);


        _this2.emit('reconnect');
      });
      this.mqtt.on('close', function () {
        _this2.log.info("[BaseClient:onClose] MQTT client connection was closed.");

        _this2.emit('close');
      });
      this.mqtt.on('offline', function () {
        var newId = uuidv4();

        _this2.log.info("[BaseClient:onOffline] MQTT client connection is offline. [" + newId + "]");

        _this2.emit('offline'); // Record the disconnect event for 5 minutes


        _this2.lostConnectionLog.put(newId, '1', 300000);

        var connectionLostCount = _this2.lostConnectionLog.size;

        _this2.log.info("[BaseClient:onOffline] Connection losses in the last 5 minutes: " + connectionLostCount);
      });
      this.mqtt.on('error', function (error) {
        _this2.log.error("[BaseClient:onError] " + error);

        var errorMsg = '' + error;

        if (errorMsg.indexOf('Not authorized') > -1) {
          _this2.log.error("[BaseClient:onError] One or more configuration parameters are wrong. Modify the configuration before trying to reconnect.");

          _this2.mqtt.end(false, function () {
            _this2.log.info("[BaseClient:onError] Closed the MQTT connection due to client misconfiguration");
          });
        }

        _this2.emit('error', error);
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this3 = this;

      if (this.mqtt == null) {
        this.log.info("[BaseClient:disconnect] Client was never connected");
        return;
      }

      this.mqtt.end(false, function () {
        _this3.log.info("[BaseClient:disconnect] Closed the MQTT connection due to disconnect() call");
      });
    }
  }, {
    key: "_subscribe",
    value: function _subscribe(topic, QoS, callback) {
      if (this.mqtt == null) {
        this.emit('error', "[BaseClient:_subscribe] MQTT Client is not initialized - call connect() first");
        return;
      }

      if (!this.mqtt.connected) {
        this.emit('error', "[BaseClient:_subscribe] MQTT Client is not connected - call connect() first");
        return;
      }

      QoS = QoS || 0;

      callback = callback || function (err, granted) {
        if (err == null) {
          for (var index in granted) {
            var grant = granted[index];
            this.log.debug("[BaseClient:_subscribe] Subscribed to " + grant.topic + " at QoS " + grant.qos);
          }
        } else {
          this.log.error("[BaseClient:_subscribe] " + err);
          this.emit("error", err);
        }
      }.bind(this);

      this.log.debug("[BaseClient:_subscribe] Subscribing to topic " + topic + " with QoS " + QoS);
      this.mqtt.subscribe(topic, {
        qos: parseInt(QoS)
      }, callback);
    }
  }, {
    key: "_unsubscribe",
    value: function _unsubscribe(topic, callback) {
      if (this.mqtt == null) {
        this.emit('error', "[BaseClient:_unsubscribe] MQTT Client is not initialized - call connect() first");
        return;
      }

      if (!this.mqtt.connected) {
        this.emit('error', "[BaseClient:_unsubscribe] MQTT Client is not connected - call connect() first");
        return;
      }

      callback = callback || function (err) {
        if (err == null) {
          this.log.debug("[BaseClient:_unsubscribe] Unsubscribed from: " + topic);
        } else {
          this.log.error("[BaseClient:_unsubscribe] " + err);
          this.emit("error", err);
        }
      }.bind(this);

      this.log.debug("[BaseClient:_unsubscribe] Unsubscribe: " + topic);
      this.mqtt.unsubscribe(topic, callback);
    }
  }, {
    key: "_publish",
    value: function _publish(topic, msg, QoS, callback) {
      QoS = QoS || 0;

      if ((_typeof(msg) === 'object' || typeof msg === 'boolean' || typeof msg === 'number') && !Buffer.isBuffer(msg)) {
        // mqtt library does not support sending JSON/Boolean/Number data. So stringifying it.
        // All JSON object, array will be encoded.
        msg = JSON.stringify(msg);
      }

      this.log.debug("[BaseClient:_publish] Publish: " + topic + ", " + msg + ", QoS : " + QoS);
      this.mqtt.publish(topic, msg, {
        qos: parseInt(QoS)
      }, callback);
    }
  }]);

  return BaseClient;
}(_events["default"].EventEmitter);

exports["default"] = BaseClient;